generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String           @id @default(cuid()) @db.VarChar
  email            String? // Not unique - allow multiple accounts with same email (different Particle accounts)
  walletAddress    String?          @unique @map("wallet_address")
  username         String           @unique
  externalId       String?          @unique @map("external_id") // Provider-specific ID (Google ID, Discord ID, Twitter ID, etc.)
  particleUserId   String?          @unique @map("particle_user_id") // Particle Network UUID - Unique per Particle account
  displayName      String?          @map("display_name")
  firstName        String?          @map("first_name")
  lastName         String?          @map("last_name")
  avatarUrl        String?          @map("avatar_url")
  points           Float            @default(0)
  streakCount      Int              @default(0) @map("streak_count")
  lastLogin        DateTime?        @map("last_login")
  createdAt        DateTime         @default(now()) @map("created_at")
  updatedAt        DateTime         @updatedAt @map("updated_at")
  referralCode     String?          @unique @map("referral_code")
  referredBy       String?          @map("referred_by") @db.VarChar
  isActive         Boolean          @default(true) @map("is_active")
  isVerified       Boolean          @default(false) @map("is_verified")
  role             String           @default("user")
  kycStatus        String           @default("pending") @map("kyc_status")
  kycData          Json?            @map("kyc_data")
  preferences      Json?            @default("{}")
  bio              String?
  website          String?
  socialLinks      Json?            @map("social_links")
  avatarData       String?          @map("avatar_data")
  avatarType       String?          @map("avatar_type")
  miningBalance    Float            @default(0) @map("mining_balance")
  pushToken        String?          @map("push_token")
  lastInactiveReminderAt DateTime? @map("last_inactive_reminder_at")
  authoredArticles Article[]        @relation("ArticleAuthor")
  reviewedArticles Article[]        @relation("ArticleReviewer")
  dailyRewards     DailyReward[]
  following        Follow[]         @relation("UserFollowing")
  followers        Follow[]         @relation("UserFollowers")
  kycSubmissions   KycSubmission[]
  leaderboards     Leaderboard[]
  miningClaims     MiningClaim[]
  miningSessions   MiningSession[]
  refereeRewards   ReferralReward[] @relation("ReferralRewardsAsReferee")
  referralRewards  ReferralReward[] @relation("ReferralRewardsAsReferrer")
  refreshTokens    RefreshToken[]
  rewards          Reward[]
  activities       UserActivity[]
  userBadges       UserBadge[]
  sessions         UserSession[]
  referredByUser   User?            @relation("UserReferrals", fields: [referredBy], references: [id])
  referrals        User[]           @relation("UserReferrals")
  walletData       WalletData[]

  // Indexes for performance optimization
  @@index([referredBy]) // For referral queries
  @@index([points]) // For leaderboard queries (ORDER BY points DESC)
  @@index([isActive]) // For filtering active users
  @@index([isActive, pushToken]) // For notification queries (isActive = true AND pushToken IS NOT NULL)
  @@index([lastLogin]) // For active user queries
  @@index([createdAt]) // For sorting by creation date
  @@index([role]) // For filtering by role
  @@map("users")
}

model Article {
  id               String         @id @default(cuid()) @db.VarChar
  title            String
  content          String
  category         String
  sourceUrl        String?        @map("source_url")
  sourceName       String?        @map("source_name")
  pointsValue      Int            @default(10) @map("points_value")
  readTimeEstimate Int?           @map("read_time_estimate")
  isFeatured       Boolean        @default(false) @map("is_featured")
  imageUrl         String?        @map("image_url")
  imageData        String?        @map("image_data")
  imageType        String?        @map("image_type")
  createdAt        DateTime       @default(now()) @map("created_at")
  updatedAt        DateTime       @updatedAt @map("updated_at")
  status           String         @default("pending")
  authorId         String?        @map("author_id") @db.VarChar
  reviewedBy       String?        @map("reviewed_by") @db.VarChar
  reviewedAt       DateTime?      @map("reviewed_at")
  rejectionReason  String?        @map("rejection_reason")
  publishedAt      DateTime?      @map("published_at")
  author           User?          @relation("ArticleAuthor", fields: [authorId], references: [id])
  reviewer         User?          @relation("ArticleReviewer", fields: [reviewedBy], references: [id])
  activities       UserActivity[]

  // Indexes for performance optimization
  @@index([authorId]) // For queries filtering by author
  @@index([status]) // For filtering by status (published, pending, etc.)
  @@index([category]) // For filtering by category
  @@index([isFeatured]) // For featured articles
  @@index([status, publishedAt]) // Composite index for published articles sorted by date
  @@index([status, createdAt]) // Composite index for published articles sorted by creation
  @@index([authorId, status]) // For user's articles by status
  @@index([publishedAt]) // For sorting published articles
  @@index([createdAt]) // For sorting by creation date
  @@map("articles")
}

model UserActivity {
  id           String   @id @default(cuid()) @db.VarChar
  userId       String   @map("user_id") @db.VarChar
  articleId    String   @map("article_id") @db.VarChar
  pointsEarned Int      @map("points_earned")
  readDuration Int?     @map("read_duration")
  completedAt  DateTime @default(now()) @map("completed_at")
  article      Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, articleId])
  // Indexes for performance optimization
  @@index([userId]) // For user activity history queries
  @@index([articleId]) // For article read count queries
  @@index([userId, completedAt]) // Composite index for user activity sorted by date
  @@index([completedAt]) // For leaderboard date range queries
  @@map("user_activities")
}

model Reward {
  id          String    @id @default(cuid()) @db.VarChar
  userId      String    @map("user_id") @db.VarChar
  rewardType  String    @map("reward_type")
  rewardValue String    @map("reward_value")
  status      String    @default("pending") @map("status")
  claimedAt   DateTime? @map("claimed_at")
  expiresAt   DateTime? @map("expires_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance optimization
  @@index([userId]) // For user reward queries
  @@index([status]) // For filtering by status
  @@index([userId, status]) // Composite index for user rewards by status
  @@index([createdAt]) // For sorting rewards by date
  @@map("rewards")
}

model Badge {
  id             String      @id @default(cuid()) @db.VarChar
  name           String      @unique
  description    String?
  iconUrl        String?     @map("icon_url")
  pointsRequired Int         @map("points_required")
  category       String?
  pointsValue    Int         @default(0) @map("points_value")
  userBadges     UserBadge[]

  @@map("badges")
}

model UserBadge {
  id       String   @id @default(cuid()) @db.VarChar
  userId   String   @map("user_id") @db.VarChar
  badgeId  String   @map("badge_id") @db.VarChar
  earnedAt DateTime @default(now()) @map("earned_at")
  isLocked Boolean  @default(false) @map("is_locked")
  badge    Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  // Indexes for performance optimization
  @@index([userId]) // For user badge queries
  @@index([userId, earnedAt]) // Composite index for user badges sorted by date
  @@index([earnedAt]) // For sorting by earned date
  @@map("user_badges")
}

model Leaderboard {
  id        String   @id @default(cuid()) @db.VarChar
  userId    String   @map("user_id") @db.VarChar
  period    String
  points    Int
  rank      Int
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, period])
  // Indexes for performance optimization
  @@index([period]) // For filtering by period
  @@index([period, points]) // Composite index for leaderboard queries sorted by points
  @@index([period, rank]) // Composite index for leaderboard queries sorted by rank
  @@map("leaderboards")
}

model MiningSession {
  id          String    @id @default(cuid()) @db.VarChar
  userId      String    @map("user_id") @db.VarChar
  startedAt   DateTime  @default(now()) @map("started_at")
  duration    Int       @default(21600)
  baseReward  Int       @default(20) @map("base_reward")
  currentRate Float     @default(20) @map("current_rate")
  totalMined  Float     @default(0) @map("total_mined")
  lastUpdate  DateTime  @default(now()) @map("last_update")
  isActive    Boolean   @default(true) @map("is_active")
  isCompleted Boolean   @default(false) @map("is_completed")
  completedAt DateTime? @map("completed_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  isClaimed   Boolean   @default(false) @map("is_claimed")
  endsAt      DateTime  @map("ends_at")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance optimization
  @@index([userId]) // For user mining session queries
  @@index([userId, isActive]) // Composite index for active user sessions
  @@index([userId, isCompleted, isClaimed]) // Composite index for unclaimed completed sessions
  @@index([isActive, endsAt]) // Composite index for expired session queries
  @@index([isActive]) // For filtering active sessions
  @@index([isCompleted]) // For filtering completed sessions
  @@index([endsAt]) // For expired session queries
  @@index([startedAt]) // For sorting by start date
  @@map("mining_sessions")
}

model MiningClaim {
  id            String   @id @default(cuid()) @db.VarChar
  userId        String   @map("user_id") @db.VarChar
  amount        Float
  miningRate    Int      @map("mining_rate")
  referralBonus Int      @map("referral_bonus")
  claimedAt     DateTime @default(now()) @map("claimed_at")
  createdAt     DateTime @default(now()) @map("created_at")
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance optimization
  @@index([userId]) // For user mining claim queries
  @@index([userId, claimedAt]) // Composite index for user claims sorted by date
  @@index([claimedAt]) // For sorting by claim date
  @@map("mining_claims")
}

model WalletData {
  id                  String   @id @default(cuid()) @db.VarChar
  userId              String   @map("user_id") @db.VarChar
  publicKey           String   @map("public_key")
  encryptedPrivateKey String   @map("encrypted_private_key")
  passwordHash        String   @map("password_hash")
  isActive            Boolean  @default(true) @map("is_active")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, publicKey])
  // Indexes for performance optimization
  @@index([userId]) // For user wallet queries
  @@index([isActive]) // For filtering active wallets
  @@map("wallet_data")
}

model KycSubmission {
  id              String    @id @default(cuid()) @db.VarChar
  userId          String    @map("user_id") @db.VarChar
  fullName        String    @map("full_name")
  dateOfBirth     String    @map("date_of_birth")
  address         String
  phoneNumber     String    @map("phone_number")
  idType          String    @map("id_type")
  idNumber        String    @map("id_number")
  idImageUrl      String    @map("id_image_url")
  selfieUrl       String    @map("selfie_url")
  status          String    @default("pending")
  rejectionReason String?   @map("rejection_reason")
  reviewedBy      String?   @map("reviewed_by") @db.VarChar
  reviewedAt      DateTime? @map("reviewed_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance optimization
  @@index([userId]) // For user KYC queries
  @@index([status]) // For filtering by status
  @@index([status, createdAt]) // Composite index for pending KYC sorted by date
  @@index([createdAt]) // For sorting by creation date
  @@map("kyc_submissions")
}

model RefreshToken {
  id        String   @id @default(cuid()) @db.VarChar
  userId    String   @map("user_id") @db.VarChar
  tokenHash String   @map("token_hash")
  isRevoked Boolean  @default(false) @map("is_revoked")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance optimization
  @@index([userId]) // For user token queries
  @@index([tokenHash]) // For token lookup (should be unique but not enforced in schema)
  @@index([isRevoked]) // For filtering revoked tokens
  @@index([expiresAt]) // For cleaning up expired tokens
  @@index([userId, isRevoked, expiresAt]) // Composite index for token validation
  @@map("refresh_tokens")
}

model UserSession {
  id           String   @id @default(cuid()) @db.VarChar
  userId       String   @map("user_id") @db.VarChar
  accessToken  String   @map("access_token")
  refreshToken String   @map("refresh_token")
  deviceInfo   String?  @map("device_info")
  ipAddress    String?  @map("ip_address") @db.VarChar
  userAgent    String?  @map("user_agent")
  isActive     Boolean  @default(true) @map("is_active")
  expiresAt    DateTime @map("expires_at")
  lastUsedAt   DateTime @default(now()) @map("last_used_at")
  createdAt    DateTime @default(now()) @map("created_at")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance optimization
  @@index([userId]) // For user session queries
  @@index([isActive]) // For filtering active sessions
  @@index([expiresAt]) // For cleaning up expired sessions
  @@index([userId, isActive, expiresAt]) // Composite index for session validation
  @@map("user_sessions")
}

model AvailableReward {
  id             String   @id @default(cuid()) @db.VarChar
  name           String
  description    String?
  type           String
  category       String
  pointsRequired Int      @map("points_required")
  value          String
  currency       String?
  isActive       Boolean  @default(true) @map("is_active")
  stock          Int?
  imageUrl       String?  @map("image_url")
  terms          String?
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Indexes for performance optimization
  @@index([isActive]) // For filtering active rewards
  @@index([pointsRequired]) // For filtering by points required
  @@index([category]) // For filtering by category
  @@index([isActive, pointsRequired]) // Composite index for active rewards sorted by points
  @@map("available_rewards")
}

model ReferralReward {
  id           String   @id @default(cuid()) @db.VarChar
  referrerId   String   @map("referrer_id") @db.VarChar
  refereeId    String   @map("referee_id") @db.VarChar
  pointsEarned Int      @map("points_earned")
  status       String   @default("pending")
  createdAt    DateTime @default(now()) @map("created_at")
  referee      User     @relation("ReferralRewardsAsReferee", fields: [refereeId], references: [id])
  referrer     User     @relation("ReferralRewardsAsReferrer", fields: [referrerId], references: [id])

  @@unique([referrerId, refereeId])
  // Indexes for performance optimization
  @@index([referrerId]) // For referrer reward queries
  @@index([refereeId]) // For referee reward queries
  @@index([status]) // For filtering by status
  @@index([referrerId, status]) // Composite index for referrer rewards by status
  @@map("referral_rewards")
}

model Follow {
  id          String   @id @default(cuid()) @db.VarChar
  followerId  String   @map("follower_id") @db.VarChar
  followingId String   @map("following_id") @db.VarChar
  createdAt   DateTime @default(now()) @map("created_at")
  follower    User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  // Indexes for performance optimization
  // Note: followerId and followingId are already indexed by the unique constraint above
  @@index([createdAt]) // For sorting by creation date
  @@map("follows")
}

model DailyReward {
  id           String   @id @default(cuid()) @db.VarChar
  userId       String   @map("user_id") @db.VarChar
  pointsEarned Int      @map("points_earned")
  streakCount  Int      @map("streak_count")
  streakBonus  Int      @map("streak_bonus")
  claimedAt    DateTime @default(now()) @map("claimed_at")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance optimization
  @@index([userId]) // For user daily reward queries
  @@index([userId, claimedAt]) // Composite index for user daily rewards sorted by date
  @@index([claimedAt]) // For sorting by claim date
  @@map("daily_rewards")
}
